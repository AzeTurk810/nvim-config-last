return {
  'hrsh7th/nvim-cmp',
  dependencies = {
    'hrsh7th/cmp-nvim-lsp',
    'hrsh7th/cmp-path',
    'saadparwaiz1/cmp_luasnip',
    'L3MON4D3/LuaSnip',
    'windwp/nvim-autopairs',
  },
  config = function()
    require('nvim-autopairs').setup({})

    local luasnip = require('luasnip')
    local snippet = luasnip.snippet
    local text = luasnip.text_node
    local s = luasnip.snippet
    local t = luasnip.text_node

    luasnip.add_snippets('cpp', {
        s('cd' , {
            t({
                '/*',
                'Telebe of Adicto && Mamedov yani AzeTurk810',
                'I see humans but no humanity',
                'Problem: $(PROBLEM)',
                'Contest: $(CONTEST)',
                'Judge: $(JUDGE)',
                'URL: $(URL)',
                'Memory Limit: $(MEMLIM)',
                'Time Limit: $(TIMELIM)',
                'Start: $(DATE)',
                '*/',
                '#include <iostream>',
                '',
                'using ll = long long;',
                'using namespace std;',
                '',
                "#define ln '\\n'",
                '#define INFi 1e9',
                '#define INFll 1e18',
                '', 
                'void solve() {',
                '\t',
                '}',
                '',
                'signed main() {',
                '\tios::sync_with_stdio(0);',
                '\tcin.tie(nullptr);',
                '\tint t = 1;',
                '// \t  cin >> t;',
                '\tfor(int cases = 0 ; cases < t;cases ++) {',
                '\t\tsolve();',
                '\t}',
                '}',
                '// Just Imaginary',
            }),
        }),
        s('start' , {
            t({
                '/*',
                'Telebe of Adicto && Mamedov yani AzeTurk810',
                'I see humans but no humanity',
                '*/',
                '#include <iostream>',
                '',
                'using ll = long long;',
                'using namespace std;',
                '',
                "#define ln '\\n'",
                '#define INFi 1e9',
                '#define INFll 1e18',
                '', 
                'struct prob {',
                '\tvoid init() {',
                '\t\t',
                '\t}',
                '\tvoid in() {',
                '\t\t',
                '\t}',
                '\tvoid solve() {',
                '\t\t',
                '\t}',
                '} prob;',
                '',
                'signed main() {',
                '\tios::sync_with_stdio(0);',
                '\tcin.tie(nullptr);',
                '\tint t = 1;',
                '// \t  cin >> t;',
                '\tfor(int cases = 0 ; cases < t;cases ++) {',
                '\t\t prob.init();',
                '\t\t prob.in();',
                '\t\t prob.solve();',
                '\t}',
                '}',
                '// Just Imaginary',
            }),
        }),
    })
    luasnip.add_snippets('cpp', {
		    -- Segment Tree
		    s('segtree', {
			t({
			    'struct segmentTree {',
			    '    int N , Null_val;',
			    '    vector<int> t;',
			    '',
			    '    segmentTree(int _n) {',
			    '        t.resize(_n * 4);',
			    '        N = _n;',
			    '    }',
			    '',
			    '    void build(int v , int l , int r , vector<int> &a) {',
			    '        if(l == r) {',
			    '            t[v] = a[l];',
			    '            return;',
			    '        }',
			    '        int mid = (l + r) >> 1;',
			    '        build((v << 1) , l , mid , a);',
			    '        build((v << 1)|1 , mid + 1 , r , a);',
			    '        t[v] = min(t[(v << 1)] , t[(v << 1)|1]);',
			    '    }',
			    '',
			    '    void upd(int v , int l , int r  , int &val , int &pos) {',
			    '        if(l == r) {',
			    '            t[v] = val;',
			    '            return;',
			    '        }',
			    '        int mid = (l + r) >> 1;',
			    '        if(mid >= pos) upd((v << 1) , l , mid , val, pos);',
			    '        else upd((v << 1)|1 , mid + 1 , r , val , pos);',
			    '        t[v] = min(t[(v << 1)] , t[(v << 1)|1]);',
			    '    }',
			    '',
			    '    int ask(int v , int l , int r , int ql , int qr) {',
			    '        if(ql <= l && r <= qr) return t[v];',
			    '        if(ql > r || l > qr) return Null_val;',
			    '        int mid = (l + r) >> 1;',
			    '        return min(ask((v << 1) , l , mid , ql , qr),',
			    '                   ask((v << 1)|1 , mid + 1 , r , ql , qr));',
			    '    }',
			    '};'
			}),
		    }),
		    -- Trie strukturu üçün snippet
		    s('trie', {
  				t({
  					'struct trie {',
					'    vector<trie*> child;',
					'    int finish = false;',
					'    int nodess;',
					'    trie() {',
					'        child.assign(26, nullptr);',
					'        finish = false;',
					'        nodess = 0;',
					'    };',
					'',
					'    void ins(string &s) {',
					'        trie *node = this;',
					'        for (char c : s) {',
					'            int id = c - \'a\';',
					'            if (!node->child[id])',
					'                node->child[id] = new trie();',
					'            node->nodess++;',
					'            node = node->child[id];',
					'        }',
					'        node->nodess++;',
					'        node->finish++;',
					'    }',
					'',
					'    bool askk(int &k, int l) {',
					'        trie *node = this;',
					'        return query(k, l, node);',
					'    }',
					'',
					'    bool query(int &k, int l, trie *node) {',
					'        bool ok = false;',
					'        if (node->nodess < k) return false;',
					'        if (!l) return node->nodess >= k;',
					'        for (int i = 0; i < 26; i++) {',
					'            if (node->child[i]) {',
					'                trie *cur = node->child[i];',
					'                if (cur->nodess >= k) ok |= query(k, l - 1, cur);',
					'                if (ok) return ok;',
					'            }',
					'        }',
					'        return ok;',
					'    }',
					'',
					'    bool ask(string &s) {',
					'        trie *node = this;',
					'        for (char &c : s) {',
					'            int id = c - \'a\';',
					'            if (!node->child[id]) return false;',
					'            node = node->child[id];',
					'        }',
					'        return node->finish;',
					'    }',
					'',
					'    void del(string &s) {',
					'        trie *node = this;',
					'        for (char &c : s) {',
					'            int id = c - \'a\';',
					'            node->nodess--;',
					'            node = node->child[id];',
					'        }',
					'        node->nodess--;',
					'        node->finish--;',
					'    }',
					'};',
				  }),
				}),
		    s('lazysegtree', {
			    t({
				'struct LazySegmentTree {',
				'    int N;',
				'    vector<long long> t, lazy;',
				'',
				'    LazySegmentTree(int _n) {',
				'        N = _n;',
				'        t.assign(4 * N, 0);',
				'        lazy.assign(4 * N, 0);',
				'    }',
				'',
				'    void push(int v, int l, int r) {',
				'        if (lazy[v]) {',
				'            t[v] += (r - l + 1) * lazy[v];',
				'            if (l != r) {',
				'                lazy[v*2] += lazy[v];',
				'                lazy[v*2+1] += lazy[v];',
				'            }',
				'            lazy[v] = 0;',
				'        }',
				'    }',
				'',
				'    void update(int v, int l, int r, int ql, int qr, int val) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return;',
				'        if (ql <= l && r <= qr) {',
				'            lazy[v] += val;',
				'            push(v, l, r);',
				'            return;',
				'        }',
				'        int mid = (l + r) >> 1;',
				'        update(v*2, l, mid, ql, qr, val);',
				'        update(v*2+1, mid+1, r, ql, qr, val);',
				'        t[v] = t[v*2] + t[v*2+1];',
				'    }',
				'',
				'    long long query(int v, int l, int r, int ql, int qr) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return 0;',
				'        if (ql <= l && r <= qr) return t[v];',
				'        int mid = (l + r) >> 1;',
				'        return query(v*2, l, mid, ql, qr) + query(v*2+1, mid+1, r, ql, qr);',
				'    }',
				'};'
			    })
			}),
			s('rmq', {
				t({
				'struct RMQ {',
				'    int N;',
				'    vector<int> t;',
				'    RMQ(int _n) {',
				'        N = _n;',
				'        t.resize(4 * N);',
				'    }',
				'',
				'    void build(int v, int l, int r, const vector<int> &a) {',
				'        if (l == r) {',
				'            t[v] = a[l];',
				'            return;',
				'        }',
				'        int m = (l + r) >> 1;',
				'        build(v*2, l, m, a);',
				'        build(v*2+1, m+1, r, a);',
				'        t[v] = min(t[v*2], t[v*2+1]);',
				'    }',
				'',
				'    int query(int v, int l, int r, int ql, int qr) {',
				'        if (qr < l || r < ql) return INT_MAX;',
				'        if (ql <= l && r <= qr) return t[v];',
				'        int m = (l + r) >> 1;',
				'        return min(query(v*2, l, m, ql, qr),',
				'                   query(v*2+1, m+1, r, ql, qr));',
				'    }',
				'',
				'    void build(const vector<int> &a) { build(1, 0, N - 1, a); }',
				'    int query(int l, int r) { return query(1, 0, N - 1, l, r); }',
				'};'
			    }),
			}),
			s('sparsetable', {
			    t({
				'struct SparseTable {',
				'    int N;',
				'    vector<vector<int>> table;',
				'    vector<int> logval;',
				'',
				'    SparseTable(const vector<int> &a) {',
				'        N = a.size();',
				'        int K = log2(N) + 1;',
				'        table.assign(K, vector<int>(N));',
				'        logval.resize(N + 1);',
				'',
				'        logval[1] = 0;',
				'        for (int i = 2; i <= N; i++)',
				'            logval[i] = logval[i/2] + 1;',
				'',
				'        for (int i = 0; i < N; i++)',
				'            table[0][i] = a[i];',
				'',
				'        for (int k = 1; k < K; k++) {',
				'            for (int i = 0; i + (1 << k) <= N; i++) {',
				'                table[k][i] = min(table[k-1][i],',
				'                                   table[k-1][i + (1 << (k-1))]);',
				'            }',
				'        }',
				'    }',
				'',
				'    int query(int l, int r) {',
				'        int k = logval[r - l + 1];',
				'        return min(table[k][l], table[k][r - (1 << k) + 1]);',
				'    }',
				'};'
			    }),
			}),
			s('eulertour', {
			    t({
				'vector<vector<int>> g;',
				'vector<int> tin, tout, depth, euler;',
				'int timer = 0;',
				'',
				'void dfs(int v, int p = -1, int d = 0) {',
				'    tin[v] = timer++;',
				'    depth[v] = d;',
				'    euler.push_back(v);',
				'',
				'    for (int to : g[v]) {',
				'        if (to != p) {',
				'            dfs(to, v, d + 1);',
				'            euler.push_back(v);',
				'        }',
				'    }',
				'',
				'    tout[v] = timer;',
				'}',
				'',
				'/*',
				'  - tin[v]: first time v is entered',
				'  - tout[v]: when DFS finishes v',
				'  - euler[]: Euler tour traversal',
				'  - depth[v]: depth of node v in the tree',
				'*/'
			    }),
			}),
			s('lazytemp', {
			    t({
				'template<typename T>',
				'struct LazySegmentTree {',
				'    int N;',
				'    vector<T> t, lazy;',
				'    T ID;',
				'    function<T(T, T)> merge;',
				'',
				'    LazySegmentTree(int _n, T id, function<T(T, T)> _merge) {',
				'        N = _n;',
				'        ID = id;',
				'        merge = _merge;',
				'        t.assign(4 * N, ID);',
				'        lazy.assign(4 * N, 0);',
				'    }',
				'',
				'    void push(int v, int l, int r) {',
				'        if (lazy[v] != 0) {',
				'            t[v] += (r - l + 1) * lazy[v];',
				'            if (l != r) {',
				'                lazy[v*2] += lazy[v];',
				'                lazy[v*2+1] += lazy[v];',
				'            }',
				'            lazy[v] = 0;',
				'        }',
				'    }',
				'',
				'    void build(int v, int l, int r, const vector<T> &a) {',
				'        if (l == r) {',
				'            t[v] = a[l];',
				'            return;',
				'        }',
				'        int m = (l + r) >> 1;',
				'        build(v*2, l, m, a);',
				'        build(v*2+1, m+1, r, a);',
				'        t[v] = merge(t[v*2], t[v*2+1]);',
				'    }',
				'',
				'    void update(int v, int l, int r, int ql, int qr, T val) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return;',
				'        if (ql <= l && r <= qr) {',
				'            lazy[v] += val;',
				'            push(v, l, r);',
				'            return;',
				'        }',
				'        int m = (l + r) >> 1;',
				'        update(v*2, l, m, ql, qr, val);',
				'        update(v*2+1, m+1, r, ql, qr, val);',
				'        t[v] = merge(t[v*2], t[v*2+1]);',
				'    }',
				'',
				'    T query(int v, int l, int r, int ql, int qr) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return ID;',
				'        if (ql <= l && r <= qr) return t[v];',
				'        int m = (l + r) >> 1;',
				'        return merge(query(v*2, l, m, ql, qr),',
				'                     query(v*2+1, m+1, r, ql, qr));',
				'    }',
				'',
				'    void build(const vector<T> &a) { build(1, 0, N - 1, a); }',
				'    void update(int l, int r, T val) { update(1, 0, N - 1, l, r, val); }',
				'    T query(int l, int r) { return query(1, 0, N - 1, l, r); }',
				'};',
			    }),
			}),
			s('lazytempasign', {
			    t({
				'template<typename T>',
				'struct LazySegmentTree {',
				'    int N;',
				'    vector<T> t, lazy;',
				'    T ID;',
				'    function<T(T, T)> merge;',
				'',
				'    LazySegmentTree(int _n, T id, function<T(T, T)> _merge) {',
				'        N = _n;',
				'        ID = id;',
				'        merge = _merge;',
				'        t.assign(4 * N, ID);',
				'        lazy.assign(4 * N, 0);',
				'    }',
				'',
				'    void push(int v, int l, int r) {',
				'        if (lazy[v] != 0) {',
				'            t[v] = lazy[v];',
				'            if (l != r) {',
				'                lazy[v*2] = lazy[v];',
				'                lazy[v*2+1] = lazy[v];',
				'            }',
				'            lazy[v] = 0;',
				'        }',
				'    }',
				'',
				'    void build(int v, int l, int r, const vector<T> &a) {',
				'        if (l == r) {',
				'            t[v] = a[l];',
				'            return;',
				'        }',
				'        int m = (l + r) >> 1;',
				'        build(v*2, l, m, a);',
				'        build(v*2+1, m+1, r, a);',
				'        t[v] = merge(t[v*2], t[v*2+1]);',
				'    }',
				'',
				'    void update(int v, int l, int r, int ql, int qr, T val) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return;',
				'        if (ql <= l && r <= qr) {',
				'            lazy[v] = val;',
				'            push(v, l, r);',
				'            return;',
				'        }',
				'        int m = (l + r) >> 1;',
				'        update(v*2, l, m, ql, qr, val);',
				'        update(v*2+1, m+1, r, ql, qr, val);',
				'        t[v] = merge(t[v*2], t[v*2+1]);',
				'    }',
				'',
				'    T query(int v, int l, int r, int ql, int qr) {',
				'        push(v, l, r);',
				'        if (qr < l || r < ql) return ID;',
				'        if (ql <= l && r <= qr) return t[v];',
				'        int m = (l + r) >> 1;',
				'        return merge(query(v*2, l, m, ql, qr),',
				'                     query(v*2+1, m+1, r, ql, qr));',
				'    }',
				'',
				'    void build(const vector<T> &a) { build(1, 0, N - 1, a); }',
				'    void update(int l, int r, T val) { update(1, 0, N - 1, l, r, val); }',
				'    T query(int l, int r) { return query(1, 0, N - 1, l, r); }',
				'};',
			    }),
			}),


		    s('sumsegtree', {
			t({
			    'struct segmentTree {',
			    '    int N , Null_val;',
			    '    vector<int> t;',
			    '',
			    '    segmentTree(int _n) {',
			    '        t.resize(_n * 4);',
			    '        N = _n;',
			    ' 	     Null_val = 0;',
			    '    }',
			    '',
			    '    void build(int v , int l , int r , vector<int> &a) {',
			    '        if(l == r) {',
			    '            t[v] = a[l];',
			    '            return;',
			    '        }',
			    '        int mid = (l + r) >> 1;',
			    '        build((v << 1) , l , mid , a);',
			    '        build((v << 1)|1 , mid + 1 , r , a);',
			    '        t[v] = t[(v << 1)] + t[(v << 1)|1];',
			    '    }',
			    '',
			    '    void upd(int v , int l , int r  , int &val , int &pos) {',
			    '        if(l == r) {',
			    '            t[v] = val;',
			    '            return;',
			    '        }',
			    '        int mid = (l + r) >> 1;',
			    '        if(mid >= pos) upd((v << 1) , l , mid , val, pos);',
			    '        else upd((v << 1)|1 , mid + 1 , r , val , pos);',
			    '        t[v] = t[(v << 1)] + t[(v << 1)|1];',
			    '    }',
			    '',
			    '    int ask(int v , int l , int r , int ql , int qr) {',
			    '        if(ql <= l && r <= qr) return t[v];',
			    '        if(ql > r || l > qr) return Null_val;',
			    '        int mid = (l + r) >> 1;',
			    '        return 	(ask((v << 1) , l , mid , ql , qr) +',
			    '                   ask((v << 1)|1 , mid + 1 , r , ql , qr));',
			    '    }',
			    '};'
			}),
		    }),

		    -- DSU (Disjoint Set Union)
		    s('dsu', {
			t({
			    'struct DSU {',
			    '    vector<int> par;',
			    '    int n , components;',
			    '',
			    '    DSU(int _n) {',
			    '        n = _n;',
			    '        components = n;',
			    '        par.assign(n , -1);',
			    '    }',
			    '',
			    '    int Find(int u) {',
			    '        if(par[u] < 0 ) return u;',
			    '        return par[u] = Find(par[u]);',
			    '    }',
			    '',
			    '    bool Union(int u , int v) {',
			    '        u = Find(u);',
			    '        v = Find(v);',
			    '        if(u != v) {',
			    '            components--;',
			    '            if(par[u] > par[v]) {',
			    '                par[v] += par[u];',
			    '                par[u] = v;',
			    '                return true;',
			    '            }',
			    '            par[u] += par[v];',
			    '            par[v] = u;',
			    '            return true;',
			    '        } else {',
			    '            return false;',
			    '        }',
			    '    }',
			    '};'
			}),
		    }),

		    -- Sparse Table
		    s('sparsetable', {
			t({
			    'struct sparseTable {',
			    '    int N , Null_val , k;',
			    '    vector<vector<int>> table;',
			    '    vector<int> mnl;',
			    '',
			    '    sparseTable(int _n , int Infval) {',
			    '        N = _n;',
			    '        Null_val = Infval;',
			    '        k = log2(N);',
			    '        mnl.resize(N + 1 , 0);',
			    '        table.resize(k + 1, vector<int>(N , Infval));',
			    '    }',
			    '',
			    '    void build(vector<int> &a) {',
			    '        mnl[1] = 0;',
			    '        for(int i=2; i<=N; i++)',
			    '            mnl[i] = mnl[i>>1] + 1;',
			    '        for(int i = 0 ; i < N ; i++)',
			    '            table[0][i] = a[i];',
			    '        for(int i = 1 ;i <= k ; i++) {',
			    '            for(int j = 0 ; (1 << i) + j <= N ; j++) {',
			    '                table[i][j] = min(table[i - 1][j], table[i - 1][j + (1<<(i - 1))]);',
			    '            }',
			    '        }',
			    '    }',
			    '',
			    '    int ask_min(int l , int r) {',
			    '        int idk = mnl[r - l + 1];',
			    '        l--; r--;',
			    '        return min(table[idk][l], table[idk][r - (1<<idk) + 1]);',
			    '    }',
			    '};'
			}),
        }),
		    -- DFS
		    s('dfs', {
			t({
			    'void dfs(int v) {',
			    '    used[v] = true;',
			    '    for(int &to : g[v]) {',
			    '        if(!used[to])',
			    '            dfs(to);',
			    '    }',
			    '}'
			}),
		    }),
        })
        

    local cmp = require('cmp')
    cmp.setup({
      window = {
        completion = cmp.config.window.bordered({
          border = 'rounded',
          scrollbar = false,
        }),
        documentation = cmp.config.window.bordered({
          border = 'rounded',
          scrollbar = false,
        }),
      },
      mapping = cmp.mapping.preset.insert({
        ['<Down>'] = cmp.mapping.select_next_item(),
        ['<Up>'] = cmp.mapping.select_prev_item(),
        ['<Tab>'] = cmp.mapping.confirm({ select = true }),
        ['<CR>'] = cmp.mapping.abort(),
      }),
      sources = cmp.config.sources({
        { name = 'nvim_lsp' },
        { name = 'luasnip' },
      }),
    })
  end
}

